inc "stdlib/os.slm"
inc "stdlib/string.slm"
inc "stdlib/range.slm"
inc "stdlib.slm"
{inc "compiler/simulator.slm"}

enum
127  EK_BACKSPACE

1000 EK_ARROW_LEFT
     EK_ARROW_RIGHT
     EK_ARROW_UP
     EK_ARROW_DOWN
     EK_DEL
     EK_PAGE_UP
     EK_PAGE_DOWN
     EK_HOME
     EK_END
end

enum
0   HL_NORMAL
    HL_COMMENT
    HL_MLCOMMENT
    HL_NUMBER
    HL_STRING
end

const HLF_NUMBERS 1
const HLF_STRINGS 2

class editorsyntax
  prop name int.SIZE
  prop flags int.SIZE
  prop scomment int.SIZE
  prop mcomments int.SIZE
  prop mcommente int.SIZE

  var tmp int.SIZE

  proc new 5 1
    editorsyntax.tmp 
    16
    (heap.zalloc)
    put disc

    editorsyntax.tmp read editorsyntax.flags . swap put disc
    editorsyntax.tmp read editorsyntax.name . swap put disc
    editorsyntax.tmp read editorsyntax.scomment . swap put disc
    editorsyntax.tmp read editorsyntax.mcommente . swap put disc
    editorsyntax.tmp read editorsyntax.mcomments . swap put disc

    editorsyntax.tmp read 

    ret
  end
end

class termios
  const NCCS 19
  prop iflag 4
  prop oflag 4
  prop cflag 4
  prop lflag 4

  prop line 1
  prop cc termios.NCCS
end

class winsize
  prop row 2
  prop col 2
  prop _ 8
end

class erow
  prop idx int.SIZE
  prop size int.SIZE
  prop rsize int.SIZE

  prop chars int.SIZE
  prop render int.SIZE

  prop hl int.SIZE
  prop hlopencomment int.SIZE

  oper proc free 1 0
    copy erow.chars . read copy NULL != if (heap.free) 0 end disc
    copy erow.render . read copy NULL != if (heap.free) 0 end disc
    copy erow.hl . read copy NULL != if (heap.free) 0 end disc

    (heap.free)
    ret
  end
end

class state
  var current int.SIZE
  prop _ 4 
  prop starttermios termios.SIZE

  prop filename int.SIZE
  prop statusmsg 80

  prop width int.SIZE
  prop height int.SIZE

  prop cx int.SIZE
  prop cy int.SIZE

  prop rx int.SIZE

  prop sx int.SIZE
  prop sy int.SIZE

  prop numrows int.SIZE
  prop rows int.SIZE

  prop syntax int.SIZE

  prop dirty int.SIZE
end

var _ 4
var raw termios.SIZE
var ws winsize.SIZE

const NUMBERLEN 6

const ISIG 1
const ICANON 2
const IEXTEN 32768
const ECHO 8
const ECHOE 16
const ECHONL 32

const BRKINT 2
const INPCK 16
const ISTRIP 32
const IXON 1024
const ICRNL 256

const OPOST 1

const VMIN 6
const VTIME 5

const TABSIZE 4

var tmprow int.SIZE
var tmpfp int.SIZE
var tmpchar int.SIZE
var tmpln int.SIZE

oper proc CTRL 1 1
  1fh &&

  ret
end

oper proc iscntrl 1 1
  copy 32 <
  swap 126 > ||

  ret
end

oper proc sepr 1 1
  copy 0 == if disc bool.true ret end

  tmpchar swap putc disc

  ",.()+-/*=~%<>[]; \t"
  do
    copy readc tmpchar readc == if
      disc bool.true ret
    end

    1 +
    copy readc 0 !=
  end
  disc

  bool.false

  ret
end

oper proc setstatus 1 0
  state.current read state.statusmsg . swap
  copy cstr.len 1 +
  copy 79 > if disc 79 end
  (mem.cpy)

  ret
end

oper proc appendstatus 1 0
  state.current read state.statusmsg . copy cstr.len + swap
  copy cstr.len 1 +
  copy 79 > if disc 79 end
  (mem.cpy)

  ret
end

oper proc getrow 1 1
  copy state.current read state.numrows . read > if
    disc
    NULL
    ret
  end

  int.SIZE *
  state.current read state.rows . read + read

  ret
end

oper proc getnumber 1 1

  ret
end

var tmpstr int.SIZE
var altchar int.SIZE

var prevsep int.SIZE
var instring int.SIZE
var incomment int.SIZE
var prevhl int.SIZE
var linecomm int.SIZE

var scslen int.SIZE
var mcslen int.SIZE
var mcelen int.SIZE

oper proc updatehi 0 0
  tmprow read erow.hl . read NULL != if
    ret
  end

  tmprow read erow.hl .
  tmprow read erow.rsize . read (heap.zalloc)
  put disc

  state.current read state.syntax . read NULL == if
    ret
  end

  tmprow read erow.idx . read 0 != if
    tmprow read erow.idx . read 1 -
    getrow erow.hlopencomment . read
    incomment swap put disc
  end

  prevsep 1 put disc
  instring 0 put disc
  linecomm 0 put disc
  prevhl HL_NORMAL put disc

  scslen 
  state.current read state.syntax . read editorsyntax.scomment . read
  copy NULL != if cstr.len end
  put disc

  mcslen
  state.current read state.syntax . read editorsyntax.mcomments . read
  copy NULL != if cstr.len end
  put disc

  mcelen 
  state.current read state.syntax . read editorsyntax.mcommente . read
  copy NULL != if cstr.len end
  put disc

  0
  do
    altchar swap put disc

    scslen read 0 !=
    incomment read ! &&
    instring read ! && if
      altchar read tmprow read erow.render . read +
      state.current read state.syntax . read editorsyntax.scomment . read
      scslen read
      (mem.eq) if
        linecomm 1 put disc
      end
    end

    mcslen read 0 != 
    mcelen read 0 != && 
    instring read ! && if
      incomment read
      copy if
        altchar read tmprow read erow.hl . read + HL_MLCOMMENT putc disc

        altchar read tmprow read erow.render . read +
        state.current read state.syntax . read editorsyntax.mcommente . read
        mcelen read
        (mem.eq) if
          altchar copy read mcelen read 1 - + put disc
          incomment 0 put disc
          prevsep 1 put disc
        end
      end
      ! 
      altchar read tmprow read erow.render . read +
      state.current read state.syntax . read editorsyntax.mcomments . read
      mcslen read 
      (mem.eq) && if
        altchar copy read mcslen read 1 - + put disc
        incomment 1 put disc
      end
    end

    state.current read state.syntax . read editorsyntax.flags . read
    copy HLF_NUMBERS && if
      altchar read tmprow read erow.render . read + readc 
      copy '0' < ! swap '9' > ! &&
      prevsep read
      prevhl read HL_NUMBER == || &&
      if 
        altchar read tmprow read erow.hl . read + HL_NUMBER putc disc
      end

      prevhl
      altchar read tmprow read erow.hl . read + readc
      put disc
    end
    copy HLF_STRINGS && if
      instring read
      copy if
        altchar read tmprow read erow.hl . read + HL_STRING putc disc
        altchar read tmprow read erow.render . read + readc 
        instring read == if
          instring 0 put disc
        end
        prevsep 1 put disc
      end
      0 == if
        altchar read tmprow read erow.render . read + readc 
        copy '"' ==
        covr '`' == ||
        covr ''' == || if
          instring
          covr
          put disc
          altchar read tmprow read erow.hl . read + HL_STRING putc disc
        end
        disc
      end
    end
    disc

    linecomm read 0 != if
      altchar read tmprow read erow.hl . read + HL_COMMENT putc disc
    end

    incomment read 0 != if
      altchar read tmprow read erow.hl . read + HL_COMMENT putc disc
    end

    prevsep
    altchar read tmprow read erow.render . read + readc sepr
    put disc

    altchar read 1 +
    altchar read
    tmprow read erow.rsize . read <
  end
  disc

  tmprow read erow.hlopencomment .
  incomment read
  covr covr != if
    tmprow read erow.idx . read 1 + getrow
    NULL != if
      tmprow read erow.idx . read 1 + getrow
      erow.hl . read NULL != if
        tmprow read erow.idx . read 1 + getrow
        erow.hl . read (heap.free)
        
        tmprow read erow.idx . read 1 + getrow
        erow.hl . NULL put disc
      end
    end
  end
  put disc

  altchar 0 put disc

  ret
end

oper proc hltocolor 1 1
  copy HL_NUMBER == if disc 3 ret end
  copy HL_STRING == if disc 2 ret end
  copy HL_COMMENT == if disc 252 ret end
  copy HL_MLCOMMENT == if disc 252 ret end
  disc 7

  ret
end

oper proc updaterow 0 0
  tmprow read erow.render . read NULL != if
    ret
  end

  tmpstr (str.new) put disc

  altchar 0 put disc
  0
  do
    copy tmprow read erow.chars . read + readc
    altchar swap putc disc

    altchar readc 9 == if
      tmpstr read
      do
        " " (str.catc)

        tmpstr read str.size . read TABSIZE /% swap disc 0 !=
      end
      tmpstr swap put disc

      ret
    end

    tmpstr read
    altchar (str.catc)
    tmpstr swap put disc
  
    1 +
    copy tmprow read erow.size . read <
  end
  disc

  altchar 0 put disc

  tmprow read erow.rsize .
  tmpstr read str.size . read 1 -
  put disc
  
  tmprow read erow.render .
  tmpstr read str.size . read
  (heap.zalloc)
  put disc

  tmprow read erow.render . read
  tmpstr read str.data .
  tmpstr read str.size . read
  (mem.cpy)

  tmprow read erow.hl . read NULL != if
    tmprow read erow.hl . read (heap.free)
    tmprow read erow.hl . NULL put disc
  end
  
  tmpstr read (str.free)

  ret
end

var tmpsize int.SIZE

oper proc cxtorx 1 1
  tmprow
  state.current read state.cy . read getrow
  put disc

  tmpsize 0 put disc

  0
  swap 1 -
  range.for : 1 0
    altchar 0 put disc
    read tmprow read erow.chars . read + readc
    altchar swap putc disc

    altchar readc 9 == if
      do
        tmpsize copy read 1 + put disc

        tmpsize read TABSIZE /% swap disc 0 !=
      end
      ret
    end
    tmpsize copy read 1 + put disc

    ret
  end

  tmpsize read

  ret
end

proc resetrow 1 0
  getrow tmprow swap put disc
  tmprow read erow.render . read NULL != if
    tmprow read erow.render . read (heap.free)
    tmprow read erow.render . NULL put disc
  end

  state.current read state.dirty . copy read 1 + put disc

  ret
end

oper proc updateft 0 0
  tmpstr (str.new) put disc

  tmpchar 0 put disc

  state.current read state.filename . read
  do
    tmpchar
    covr readc
    putc disc

    tmpstr read
    tmpchar (str.catc)
    tmpstr swap put disc

    tmpchar readc '.' == if
      tmpstr read str.size . 0 put disc
    end

    1 +
    copy readc 0 !=
  end
  disc

  0
  do
    copy getrow NULL == if brk end
    copy resetrow
    
    1 +

    1  
  end
  disc

  tmpstr read str.data .
  tmpstr read str.size . read + 0 putc disc

  tmpstr read str.data . "slm" (cstr.eq) if
    state.current read state.syntax .
    "{" "}" "$$"
    "slam" HLF_NUMBERS HLF_STRINGS || editorsyntax.new
    put disc

    tmpstr read (str.free)

    ret
  end

  tmpstr read str.data . "spk" (cstr.eq) if
    state.current read state.syntax .
    "{" "}" "$$"
    "spakig" HLF_STRINGS editorsyntax.new
    put disc

    tmpstr read (str.free)

    ret
  end

  tmpstr read (str.free)

  ret
end

{ file io }
oper proc editoropen 1 0
  copy state.current read state.filename . swap put disc

  (filestream.new)
  tmpfp swap put disc

  0
  do
    copy getrow NULL == if brk end
    copy getrow erow.free
    
    1 +

    1  
  end
  disc
  
  state.current read state.numrows . 0 put disc

  do
    tmpln (str.new) put disc
    tmpchar 0 put disc
    do
      tmpchar
      tmpfp read (filestream.readchar)
      putc disc

      tmpchar readc
      copy 10 == if
        disc
        brk
      end
      copy 13 == if
        disc
        brk
      end
      copy 0 == if
        disc
        brk
      end
      disc
      
      tmpln read
      tmpchar
      (str.catc)
      tmpln swap put disc 

      1
    end

    state.current read state.rows . read
    state.current read state.numrows . read 1 + int.SIZE *
    (heap.realloc)
    state.current read state.rows . swap put disc


    state.current read state.rows . read
    state.current read state.numrows . read int.SIZE * + 
    erow.SIZE (heap.zalloc)
    put disc

    tmpln read str.size . read
    state.current read state.rows . read
    state.current read state.numrows . read int.SIZE * + read
    erow.size .
    swap put disc

    tmpln read str.size . read
    state.current read state.rows . read
    state.current read state.numrows . read int.SIZE * + read
    erow.chars .
    swap 1 + (heap.zalloc) put disc

    state.current read state.rows . read
    state.current read state.numrows . read int.SIZE * + read
    erow.chars . read
    tmpln read str.data .
    tmpln read str.size . read
    (mem.cpy)

    state.current read state.rows . read
    state.current read state.numrows . read int.SIZE * + read
    erow.rsize .
    0 put disc

    state.current read state.numrows . read getrow
    tmprow swap put disc

    updaterow

    state.current read state.numrows . copy read 1 + put disc
    tmpln read (str.free)
    
    tmpchar readc 0 !=
  end

  state.current read state.numrows . copy read 1 - put disc

  "Opened " setstatus
  state.current read state.filename . read appendstatus

  updateft

  ret
end

var tmpat int.SIZE

oper proc insertchar 1 0
  state.current read state.cy . read getrow erow.chars . read
  state.current read state.cy . read getrow erow.size . read 2 +
  (heap.realloc)
  state.current read state.cy . read getrow erow.chars . swap put disc

  state.current read state.cx . read
  tmpat swap put disc
  
  tmpat read 0 < 
  tmpat read
  state.current read state.cy . read getrow erow.size . read > ||
  if 
    disc
    state.current read state.cy . read getrow erow.size . read
  end

  state.current read state.cy . read getrow erow.chars . read tmpat read +
  state.current read state.cy . read getrow erow.chars . read tmpat read + 1 +
  state.current read state.cy . read getrow erow.size . read tmpat read - 1 +
  movemem

  state.current read state.cy . read getrow erow.size . copy read 1 + put disc

  state.current read state.cx . copy read 1 + put disc
  
  state.current read state.cy . read getrow erow.chars . read
  tmpat read + swap putc disc

  state.current read state.cy . read resetrow

  ret
end

oper proc insertrow 1 0
  tmpstr swap put disc

  state.current read state.cy . read
  tmpat swap put disc

  tmpat read 0 < 
  tmpat read
  state.current read state.numrows . read > ||
  if
    ret
  end

  state.current read state.rows . read
  state.current read state.numrows . read 1 + int.SIZE *
  (heap.realloc)
  state.current read state.rows . swap put disc

  state.current read state.rows . read tmpat read int.SIZE * +
  state.current read state.rows . read tmpat read 1 + int.SIZE * +
  state.current read state.numrows . read tmpat read - int.SIZE *
  movemem

  state.current read state.numrows . copy read 1 + put disc

  tmprow
  erow.SIZE (heap.zalloc)
  put disc

  tmprow read erow.size .
  tmpstr read cstr.len
  put disc

  tmprow read erow.chars .
  tmpstr read cstr.len 1 + (heap.zalloc)
  put disc

  tmprow read erow.chars . read
  tmpstr read
  tmpstr read cstr.len
  (mem.cpy)

  state.current read state.rows . read
  tmpat read int.SIZE * +
  tmprow read
  put disc
  
  tmpat read resetrow

  ret
end

oper proc insertline 0 0
  state.current read state.cy . copy read 1 + put disc
  state.current read state.cy . read 1 - getrow erow.chars . read
  state.current read state.cx . read +
  insertrow
  state.current read state.cy . read 1 - getrow erow.chars . read
  state.current read state.cx . read + 0 putc disc

  state.current read state.cy . read 1 - getrow erow.size .
  state.current read state.cx . read
  put disc

  state.current read state.cy . read 1 - resetrow
  state.current read state.cx . 0 put disc

  ret
end

oper proc delrow 1 0
  tmpat swap put disc

  tmpat read getrow erow.free
  
  tmpat read 1 + int.SIZE *
  state.current read state.rows . read + 
  tmpat read int.SIZE *
  state.current read state.rows . read + 
  state.current read state.numrows . read tmpat read - int.SIZE *
  movemem

  state.current read state.numrows . copy read 1 - put disc

  ret
end

oper proc appendrow 1 0
  tmpat swap put disc
  tmpstr (str.new) put disc

  tmpstr read
  tmpat read getrow erow.chars . read (str.catc)
  tmpat read 1 + getrow erow.chars . read (str.catc)
  tmpstr swap put disc

  tmpat read getrow erow.chars . read
  tmpstr read str.size . read
  (heap.realloc)
  tmpat read getrow erow.chars . swap put disc
  
  tmpat read getrow erow.chars . read
  tmpstr read str.data .
  tmpstr read str.size . read
  (mem.cpy)

  tmpat read getrow erow.size .
  tmpstr read str.size . read
  put disc
  
  tmpstr read (str.free)

  state.current read state.cy . read resetrow

  ret
end

oper proc delchar 1 0
  tmpat swap put disc
 
  tmpat read -1 ==
  state.current read state.cy . read 0 == && if ret end

  tmpat read -1 == if
    state.current read state.cx .
    state.current read state.cy . read 1 - getrow erow.size . read
    put disc

    state.current read state.cy . read 1 -
    appendrow
    state.current read state.cy . read
    delrow
    state.current read state.cy . copy read 1 - put disc

    state.current read state.cy . read resetrow

    ret
  end
  
  tmpat read 0 < 
  tmpat read
  state.current read state.cy . read getrow erow.size . read < ! ||
  if 
    disc
    ret
  end

  state.current read state.cy . read getrow erow.chars . read tmpat read + 1 +
  state.current read state.cy . read getrow erow.chars . read tmpat read +
  state.current read state.cy . read getrow erow.size . read tmpat read - 1 +
  movemem

  state.current read state.cy . read getrow erow.size . copy read 1 - put disc

  state.current read state.cx . copy read 1 - put disc

  state.current read state.cy . read resetrow

  ret
end

oper proc rowstostr 0 0
  tmpln (str.new) put disc

  0
  state.current read state.numrows . read 1 -
  range.for : 1 0
    read getrow
    tmprow swap put disc

    tmprow read NULL == if ret end

    tmprow read erow.chars . read
    tmprow read erow.size . read + 0 putc disc

    tmpln read
    tmprow read erow.chars . read (str.catc)
    "\n" (str.catc)
    tmpln swap put disc

    ret
  end

  ret
end

oper proc rawmodeon 0 0
  raw
  5401h
  0
  sysc.IOCTL
  sys3
  disc

  state.current read state.starttermios .
  raw termios.SIZE (mem.cpy)

  raw termios.iflag .
  copy read
  BRKINT ICRNL || INPCK || ISTRIP || IXON || ~ &&
  put disc

  raw termios.oflag .
  copy read
  OPOST ~ &&
  put disc

  raw termios.lflag .
  copy read
  ECHO ISIG || ICANON || IEXTEN || ~ &&
  put disc

  raw termios.cc . VMIN + 0 putc disc
  raw termios.cc . VTIME + 1 putc disc

  raw
  5404h
  0
  sysc.IOCTL
  sys3
  disc

  ret
end

oper proc rawmodeoff 0 0
  state.current read state.starttermios .
  5404h
  0
  sysc.IOCTL
  sys3
  disc

  ret
end

oper proc die 1 0
  cstr.print
  "\e[2J" cstr.print
  "\e[H" cstr.print
  rawmodeoff

  1 quit
end

var tmplen int.SIZE

class renderer
  var abuf int.SIZE
  var leftbuf int.SIZE
  var rightbuf int.SIZE
  var fgcolor int.SIZE
  var bgcolor int.SIZE

  oper proc setfgcolor 1 0
    renderer.fgcolor read covr == if disc ret end
    renderer.fgcolor swap put disc

    renderer.abuf read
    "\e[38;5;" (str.catc)
    renderer.fgcolor read int.cstr (str.catc)
    "m" (str.catc)
    renderer.abuf swap put disc

    ret
  end

  oper proc setbgcolor 1 0
    renderer.bgcolor read covr == if disc ret end
    renderer.bgcolor swap put disc

    renderer.abuf read
    "\e[48;5;" (str.catc)
    renderer.bgcolor read int.cstr (str.catc)
    "m" (str.catc)
    renderer.abuf swap put disc

    ret
  end

  oper proc renderstatus 0 0
    renderer.leftbuf (str.new) put disc
    renderer.rightbuf (str.new) put disc

    253 renderer.setfgcolor
    252 renderer.setbgcolor

    renderer.rightbuf read
    state.current read state.cy . read int.cstr (str.catc)
    "/" (str.catc)
    state.current read state.numrows . read int.cstr (str.catc)
    " " (str.catc)
    "no ft"
    state.current read state.syntax . read NULL != if
      disc state.current read state.syntax . read editorsyntax.name . read
    end (str.catc)
    renderer.rightbuf swap put disc

    renderer.leftbuf read
    "[NO NAME]"
    state.current read state.filename . read NULL != if
      disc state.current read state.filename . read
    end (str.catc)
    state.current read state.dirty . read if
      " (modified)" (str.catc)
    end
    renderer.leftbuf swap put disc

    renderer.leftbuf read str.size . read
    state.current read state.width . read >
    if
      renderer.leftbuf read str.size . 
      state.current read state.width . read
      put disc

      renderer.leftbuf read str.size . read 1 + 
      renderer.leftbuf read str.data . +
      0 putc disc
    end

    renderer.abuf read
    renderer.leftbuf read str.data . (str.catc)
    renderer.abuf swap put disc

    renderer.leftbuf read str.size . read
    copy
    state.current read state.width . read != if
      do
        renderer.abuf read
        " " (str.catc)
        renderer.abuf swap put disc

        1 +
        copy
        renderer.rightbuf read str.size . read +
        state.current read state.width . read == if
          renderer.abuf read
          renderer.rightbuf read str.data . (str.catc)
          renderer.abuf swap put disc

          brk
        end
        copy state.current read state.width . read <
      end
    end
    disc

    renderer.abuf read
    "\e[m" (str.catc)
    "\r\n" (str.catc)
    "\e[K" (str.catc)
    state.current read state.statusmsg . (str.catc)
    renderer.abuf swap put disc

    renderer.leftbuf read (str.free)
    renderer.rightbuf read (str.free)

    ret
  end

  oper proc renderrows 0 0
    0
    state.current read state.height . read 1 -
    range.for : 1 0
      read state.current read state.sy . read +

      copy getrow tmprow swap put disc

      copy state.current read state.numrows . read < ! if 
        renderer.abuf read
        "~" (str.catc)
        renderer.abuf swap put disc
      end
      copy state.current read state.numrows . read < if
        tmprow read erow.idx . covr put disc
        
        updaterow
        updatehi
        tmprow read erow.rsize . read 
        state.current read state.sx . read - 1 +
        tmplen swap put disc
        
        tmplen read 0 < if
          tmplen 0 put disc
        end
        
        tmplen read
        state.current read state.width . read NUMBERLEN - > if
          tmplen state.current read state.width . read NUMBERLEN - put disc
        end

        0 renderer.setbgcolor
        7 renderer.setfgcolor

        renderer.abuf read str.size . read NUMBERLEN + 1 -
        tmprow read erow.idx . read int.cstr cstr.len -

        do
          renderer.abuf read
          " " (str.catc)
          renderer.abuf swap put disc

          renderer.abuf read str.size . read 
          covr <
        end
        disc

        renderer.abuf read
        tmprow read erow.idx . read int.cstr (str.catc)
        "â”‚" (str.catc)
        renderer.abuf swap put disc

        0 renderer.setbgcolor
        7 renderer.setfgcolor

        tmplen read 0 > if
          tmpchar 0 put disc
          0
          do
            copy tmprow read erow.render . read + readc
            tmpchar swap putc disc

            copy tmprow read erow.hl . read + readc
            hltocolor renderer.setfgcolor
            
            tmpchar readc iscntrl ! if
              renderer.abuf read
              tmpchar (str.catc)
              renderer.abuf swap put disc
            end
            tmpchar readc iscntrl if
              7 renderer.setbgcolor
              0 renderer.setfgcolor
              renderer.abuf read
              tmpchar readc 26 < if
                tmpchar readc '@' +
                altchar swap putc (str.catc)
              end
              tmpchar readc 26 < ! if
                tmpchar '?' putc (str.catc)
              end
              renderer.abuf swap put disc
              0 renderer.setbgcolor
              7 renderer.setfgcolor
            end

            1 +
            copy tmplen read <
          end
          disc
        end
      end
      disc
      renderer.abuf read
      "\e[K" (str.catc)
      "\r\n" (str.catc)
      renderer.abuf swap put disc

      ret
    end

    ret
  end

  oper proc blit 0 0
    renderer.abuf read
    (str.print)

    ret
  end

  oper proc movecursor 0 0
    state.current read state.rx . read 1 + NUMBERLEN +
    state.current read state.sx . read -
    state.current read state.cy . read 1 +
    state.current read state.sy . read -

    renderer.abuf read
    "\e[" (str.catc)
    swap int.cstr (str.catc)
    ";" (str.catc)
    swap int.cstr (str.catc)
    "H" (str.catc)
    renderer.abuf swap put disc

    ret
  end

  oper proc refreshscreen 0 0
    renderer.abuf
    (str.new)
    put disc

    renderer.abuf read
    "\e[?25l" (str.catc)
    "\e[H" (str.catc)
    renderer.abuf swap put disc

    renderer.renderrows
    renderer.renderstatus
    renderer.movecursor

    renderer.abuf read
    "\e[?25h" (str.catc)
    renderer.abuf swap put disc

    renderer.blit

    renderer.abuf read
    (str.free)

    ret
  end
end

var pbuff int.SIZE
var psize int.SIZE

oper proc prompt 1 1
  psize
  covr cstr.len
  put disc

  pbuff (str.new) put disc

  pbuff read
  swap (str.catc)
  pbuff swap put disc

  do
    pbuff read str.data . setstatus
    renderer.refreshscreen
    tmpchar 0 put disc
    1 tmpchar 0 (os.readf)

    tmpchar readc 13 == if 
      "" setstatus
      pbuff read str.data . 
      pbuff read str.size . read + 0 putc disc 
      pbuff read str.data . psize read +
      ret
    end
    pbuff read str.size . read 0 !=
    tmpchar readc 127 == && if
      pbuff read str.size . copy read 1 - put disc
      pbuff read str.data . 
      pbuff read str.size . read + 0 putc disc 
    end
    tmpchar readc 32 >
    tmpchar readc 127 < &&
    tmpchar readc 0 != && if
      pbuff read
      tmpchar (str.catc)
      pbuff swap put disc
    end

    1
  end

  NULL ret
end

class runner
  oper proc run 0 0
    {
    511
    65
    "/tmp/runner.slm"
    -100
    (os.open)
    tmpfp swap put disc

    tmpstr (str.new) put disc

    tmpstr read
    "proc main " (str.catc)
    ">>" prompt (str.catc)
    " end " (str.catc)
    tmpstr swap put disc

    tmpstr read str.size . read
    tmpfp read
    77
    sys2
    disc

    tmpstr read str.size . read
    tmpstr read str.data .
    tmpfp read
    (os.write)

    tmpstr read (str.free)

    tmpfp read
    (os.close)

    "/tmp/runner.slm"

    bool.false
    (lexer.new) (lexer.run)
    (parser.new) (parser.run)
    (simulator.visitnode)
    simulator.SUCCESS != if
      "ERR" setstatus
    end
    }

    ret
  end
end

oper proc save 0 0
  state.current read state.filename . read NULL == if
    "Save As: " prompt

    state.current read state.filename . swap put disc

    updateft
  end

  rowstostr
  
  511
  65
  state.current read state.filename . read
  -100
  (os.open)
  tmpfp swap put disc

  tmpln read str.size . read
  tmpfp read
  77
  sys2
  disc

  tmpln read str.size . read
  tmpln read str.data . 
  tmpfp read
  (os.write)

  tmpfp read
  (os.close)

  tmpln read str.size . read
  "Wrote " setstatus
  int.cstr appendstatus
  " bytes" appendstatus

  tmpln read (str.free)

  state.current read state.dirty . 0 put disc

  ret
end

oper proc getsize 0 0
  ws
  5413h
  1
  sysc.IOCTL
  sys3
  disc

  state.current read state.height .
  ws winsize.row . read 65535 && 2 -
  put disc

  state.current read state.width .
  ws winsize.col . read 65535 &&
  put disc

  ret
end

var nread int.SIZE

oper proc readchar 0 1
  tmpchar
  0
  putc disc

  do
    1 tmpchar 0 (os.readf)
    nread swap put disc

    nread read -1 ==
  end

  tmpchar readc
  copy 27 == if
    1 tmpchar 0 (os.readf)
    tmpchar readc

    copy '[' == if
      1 tmpchar 0 (os.readf)
      tmpchar readc

      copy 'A' == if 
        disc disc disc
        EK_ARROW_UP ret
      end
      copy 'B' == if 
        disc disc disc
        EK_ARROW_DOWN ret
      end
      copy 'C' == if 
        disc disc disc
        EK_ARROW_RIGHT ret
      end
      copy 'D' == if 
        disc disc disc
        EK_ARROW_LEFT ret
      end
      copy 'H' == if 
        disc disc disc
        EK_HOME ret
      end
      copy 'D' == if 
        disc disc disc
        EK_END ret
      end

      copy '1' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_HOME ret
        end
        disc
      end
      copy '3' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_DEL ret
        end
        disc
      end
      copy '4' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_END ret
        end
        disc
      end
      copy '5' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_PAGE_UP ret
        end
        disc
      end
      copy '6' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_PAGE_DOWN ret
        end
        disc
      end
      disc
    end
    copy 'O' == if
      1 tmpchar 0 (os.readf)
      tmpchar readc

      copy 'H' == if 
        disc disc disc
        EK_HOME ret
      end
      copy 'D' == if 
        disc disc disc
        EK_END ret
      end
      disc
    end
    disc
  end

  ret
end

oper proc scroll 0 0
  state.current read state.rx .
  0 put disc

  state.current read state.cy . read
  state.current read state.numrows . read < if
    state.current read state.rx .
    state.current read state.cx . read
    cxtorx put disc
  end

  state.current read state.sy . read 
  state.current read state.cy . read > if
    state.current read state.sy .
    state.current read state.cy . read
    put disc
  end

  state.current read state.sy . read 
  state.current read state.height . read +
  state.current read state.cy . read > ! if
    state.current read state.sy .

    state.current read state.cy . read
    state.current read state.height . read - 1 +
    
    put disc
  end
  state.current read state.sx . read 
  state.current read state.rx . read > if
    state.current read state.sx .
    state.current read state.rx . read
    put disc
  end

  state.current read state.sx . read 
  state.current read state.width . read +
  state.current read state.rx . read > ! if
    state.current read state.sx .

    state.current read state.rx . read
    state.current read state.width . read - 1 +
    
    put disc
  end

  ret
end

enum
0   UP
    DOWN
    LEFT
    RIGHT
end

oper proc movecursor 1 0
  copy UP == if 
    state.current read state.cy . read 0 > if
      state.current read state.cy . copy read 1 - put disc
    end
  end
  copy DOWN == if 
    state.current read state.cy . read
    state.current read state.numrows . read 1 - < if
      state.current read state.cy . copy read 1 + put disc
    end
  end
  copy LEFT == if
    state.current read state.cx . read 0 != if 
      disc
      state.current read state.cx . copy read 1 - put disc

      ret
    end
    state.current read state.cy . read 0 > if 
      state.current read state.cy . copy read 1 - put disc
      
      state.current read state.cx .
      state.current read state.cy . read getrow erow.size . read
      put disc
      
    end
  end
  copy RIGHT == if
    state.current read state.cy . read getrow
    NULL != if
      state.current read state.cx . read 
      state.current read state.cy . read getrow erow.size . read
      < if 
        disc
        state.current read state.cx . copy read 1 + put disc

        ret
      end
      state.current read state.cx . read 
      state.current read state.cy . read getrow erow.size . read
      == if 
        state.current read state.cy . copy read 1 + put disc
        disc
        state.current read state.cx . 0 put disc

        ret
      end
    end
  end
  disc

  state.current read state.cx . read 
  state.current read state.cy . read getrow erow.size . read > if
    state.current read state.cx .
    state.current read state.cy . read getrow erow.size . read
    put disc
  end
  
  ret
end

oper proc processkey 1 0
  copy 's' CTRL == if
    save

    disc ret
  end
  copy 'r' CTRL == if
    runner.run

    disc ret
  end
  copy 'g' CTRL == if
    state.current read state.cy .
    state.current read state.numrows . read
    put disc
    
    state.current read state.cx .
    state.current read state.cy . read getrow erow.size . read
    put disc

    disc ret
  end
  copy 'q' CTRL == if
    "\e[2J" cstr.print
    "\e[H" cstr.print

    rawmodeoff
    
    0 quit
  end
  copy 13 == if
    insertline

    disc ret
  end
  copy EK_BACKSPACE ==
  covr 'h' CTRL == || if 
    state.current read state.cx . read 1 -
    delchar

    disc ret
  end
  covr EK_DEL == if
    RIGHT movecursor
    state.current read state.cx . read 1 -
    delchar

    disc ret
  end
  copy EK_ARROW_UP == if 
    UP movecursor

    disc ret
  end
  copy EK_ARROW_DOWN == if 
    DOWN movecursor

    disc ret
  end
  copy EK_ARROW_LEFT == if 
    LEFT movecursor

    disc ret
  end
  copy EK_ARROW_RIGHT == if 
    RIGHT movecursor

    disc ret
  end
  copy EK_PAGE_UP == if 
    state.current read state.height . read
    do
      UP movecursor
      1 - copy
    end
    disc

    disc ret
  end
  copy EK_PAGE_DOWN == if 
    state.current read state.height . read
    do
      DOWN movecursor
      1 - copy
    end
    disc

    disc ret
  end
  copy 'o' CTRL == if
    "Open: " prompt
    editoropen

    disc ret
  end
  copy 9 == if
    9 insertchar

    disc ret
  end
  copy iscntrl
  covr 'l' CTRL == ||
  covr 27 == || if
    disc ret
  end

  insertchar

  ret
end

oper proc main 0 0
  state.current
  state.SIZE (heap.zalloc)
  put disc

  state.current read state.rows .
  0 (heap.zalloc)
  put disc  

  argc 1 > if 
    1 (os.args) editoropen
  end
  argc 1 == if 
    "" insertrow
  end

  rawmodeon
  getsize

  "Welcome to Sled" setstatus

  scroll
  renderer.refreshscreen
  do
    readchar
    copy if
      processkey 0
      scroll
      renderer.refreshscreen
    end
    disc

    1
  end

  ret
end
