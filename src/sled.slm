inc "stdlib/os.slm"
inc "stdlib/string.slm"
inc "stdlib/range.slm"
inc "stdlib/arrays.slm"
inc "stdlib.slm"
{inc "compiler/simulator.slm"}

enum
127  EK_BACKSPACE

1000 EK_ARROW_LEFT
     EK_ARROW_RIGHT
     EK_ARROW_UP
     EK_ARROW_DOWN
     EK_DEL
     EK_PAGE_UP
     EK_PAGE_DOWN
     EK_HOME
     EK_END
end

enum
0   HL_NORMAL
    HL_COMMENT
    HL_MLCOMMENT
    HL_KEYWORD1
    HL_KEYWORD2
    HL_NUMBER
    HL_STRING
    HL_CALL
end

oper proc hltocolor 1 1
  copy HL_NUMBER == if disc 3 ret end
  copy HL_STRING == if disc 2 ret end
  copy HL_KEYWORD1 == if disc 4 ret end
  copy HL_KEYWORD2 == if disc 5 ret end
  copy HL_CALL == if disc 4 ret end
  copy HL_COMMENT == if disc 252 ret end
  copy HL_MLCOMMENT == if disc 252 ret end
  disc 7

  ret
end

enum
0   M_NORMAL
    M_INSERT
end

oper proc modetostr 1 1
  copy M_INSERT == if disc "INSERT" ret end
  copy M_NORMAL == if disc "NORMAL" ret end
  disc "??????"

  ret
end

var mode int.SIZE

const HLF_NUMBERS 1
const HLF_STRINGS 2
const HLF_CALLS 4

class editorsyntax
  prop name int.SIZE
  prop flags int.SIZE
  prop scomment int.SIZE
  prop mcomments int.SIZE
  prop mcommente int.SIZE

  prop kw1 int.SIZE
  prop kw2 int.SIZE

  var tmp int.SIZE

  proc new 6 1
    editorsyntax.tmp 
    int.SIZE 6 *
    (heap.zalloc)
    put disc

    editorsyntax.tmp read editorsyntax.flags . swap put disc
    editorsyntax.tmp read editorsyntax.name . swap put disc
    editorsyntax.tmp read editorsyntax.scomment . swap put disc
    editorsyntax.tmp read editorsyntax.mcommente . swap put disc
    editorsyntax.tmp read editorsyntax.mcomments . swap put disc

    editorsyntax.tmp read editorsyntax.kw2 . swap put disc
    editorsyntax.tmp read editorsyntax.kw1 . swap put disc

    editorsyntax.tmp read 

    ret
  end
end

class termios
  const NCCS 19
  prop iflag 4
  prop oflag 4
  prop cflag 4
  prop lflag 4

  prop line 1
  prop cc termios.NCCS
end

class winsize
  prop row 2
  prop col 2
  prop _ 8
end

class erow
  prop idx int.SIZE
  prop size int.SIZE
  prop rsize int.SIZE

  prop chars int.SIZE
  prop render int.SIZE

  prop hl int.SIZE
  prop hlopencomment int.SIZE

  oper proc free 1 0
    copy erow.chars . read copy NULL != if (heap.free) 0 end disc
    copy erow.render . read copy NULL != if (heap.free) 0 end disc
    copy erow.hl . read copy NULL != if (heap.free) 0 end disc

    (heap.free)
    ret
  end
end

class screen
  var width int.SIZE
  var height int.SIZE
end


class buffer
  var buffers int.SIZE
  var idx int.SIZE

  prop _ 4 
  prop starttermios termios.SIZE

  prop filename int.SIZE
  prop statusmsg 80
  
  prop cx int.SIZE
  prop cy int.SIZE

  prop rx int.SIZE

  prop sx int.SIZE
  prop sy int.SIZE

  prop numrows int.SIZE
  prop rows int.SIZE

  prop syntax int.SIZE
  prop dirty int.SIZE

  proc current 0 1
    buffer.buffers read
    buffer.idx read
    (dlist.ptrat)

    ret
  end

  proc cnt 0 1
    buffer.buffers read
    (dlist.len)

    ret
  end
end

var _ 4
var raw termios.SIZE
var ws winsize.SIZE

const NUMBERLEN 6

const ISIG 1
const ICANON 2
const IEXTEN 32768
const ECHO 8
const ECHOE 16
const ECHONL 32

const BRKINT 2
const INPCK 16
const ISTRIP 32
const IXON 1024
const ICRNL 256

const OPOST 1

const VMIN 6
const VTIME 5

const TABSIZE 4

var tmprow int.SIZE
var tmpfp int.SIZE
var tmpchar int.SIZE
var tmpln int.SIZE
var tmpat int.SIZE

oper proc CTRL 1 1
  1fh &&

  ret
end

oper proc iscntrl 1 1
  copy 32 <
  swap 126 > ||

  ret
end

oper proc sepr 1 1
  copy 0 == if disc bool.true ret end

  tmpchar swap putc disc

  " \t"
  do
    copy readc tmpchar readc == if
      disc bool.true ret
    end

    1 +
    copy readc 0 !=
  end
  disc

  bool.false

  ret
end

oper proc setstatus 1 0
  buffer.current read buffer.statusmsg . swap
  copy cstr.len 1 +
  copy 79 > if disc 79 end
  (mem.cpy)

  ret
end

oper proc appendstatus 1 0
  buffer.current read buffer.statusmsg . copy cstr.len + swap
  copy cstr.len 1 +
  copy 79 > if disc 79 end
  (mem.cpy)

  ret
end

oper proc getrow 1 1
  copy buffer.current read buffer.numrows . read > if
    disc
    NULL
    ret
  end

  int.SIZE *
  buffer.current read buffer.rows . read + read

  ret
end

oper proc getnumber 1 1

  ret
end

var tmpstr int.SIZE
var altchar int.SIZE

var prevsep int.SIZE
var instring int.SIZE
var incall int.SIZE
var incomment int.SIZE
var prevhl int.SIZE
var linecomm int.SIZE

var scslen int.SIZE
var mcslen int.SIZE
var mcelen int.SIZE

var tmpkwc int.SIZE

proc initbuffers 0 0
  buffer.buffers int.SIZE (dlist.new) put disc
  buffer.buffers read
  buffer.SIZE (heap.zalloc)
  tmpchar swap put
  (dlist.append)
  disc
  
  tmpchar 0 put disc

  buffer.current read buffer.rows .
  0 (heap.zalloc)
  put disc  

  ret
end

proc addbuffer 0 0
  buffer.buffers read
  buffer.SIZE (heap.zalloc)
  tmpchar swap put
  (dlist.append)
  dlist.size . read 1 -
  buffer.idx swap put disc
  
  tmpchar 0 put disc

  buffer.current read buffer.rows .
  0 (heap.zalloc)
  put disc  

  ret
end

oper proc checkkw 2 1
  swap tmpkwc swap put disc

  do
    tmpkwc read
    covr
    copy cstr.len
    (mem.eq) if
      copy cstr.len
      swap disc
      ret
    end
    copy cstr.len + 1 +

    copy readc 0 !=
  end
  disc

  0

  ret
end

proc resetrow 1 0
  getrow tmprow swap put disc
  tmprow read erow.render . read NULL != if
    tmprow read erow.render . read (heap.free)
    tmprow read erow.render . NULL put disc
  end

  buffer.current read buffer.dirty . copy read 1 + put disc

  ret
end

oper proc insertrow 1 0
  tmpstr swap put disc

  buffer.current read buffer.cy . read
  tmpat swap put disc

  tmpat read 0 < 
  tmpat read
  buffer.current read buffer.numrows . read > ||
  if
    ret
  end

  buffer.current read buffer.rows . read
  buffer.current read buffer.numrows . read 1 + int.SIZE *
  (heap.realloc)
  buffer.current read buffer.rows . swap put disc

  buffer.current read buffer.numrows . copy read 1 + put disc

  buffer.current read buffer.numrows . read 1 != if
    buffer.current read buffer.rows . read tmpat read int.SIZE * +
    buffer.current read buffer.rows . read tmpat read 1 + int.SIZE * +
    buffer.current read buffer.numrows . read tmpat read - 1 - int.SIZE *
    movemem
  end

  tmprow
  erow.SIZE (heap.zalloc)
  put disc

  tmprow read erow.size .
  tmpstr read cstr.len
  put disc

  tmprow read erow.chars .
  tmpstr read cstr.len 1 + (heap.zalloc)
  put disc

  tmprow read erow.chars . read
  tmpstr read
  tmpstr read cstr.len
  (mem.cpy)

  buffer.current read buffer.rows . read
  tmpat read int.SIZE * +
  tmprow read
  put disc
  
  tmpat read resetrow

  ret
end

oper proc updatehi 0 0
  tmprow read erow.hl . read NULL != if
    ret
  end

  tmprow read erow.hl .
  tmprow read erow.rsize . read (heap.zalloc)
  put disc

  buffer.current read buffer.syntax . read NULL == if
    ret
  end

  tmprow read erow.idx . read 0 != if
    tmprow read erow.idx . read 1 -
    getrow erow.hlopencomment . read
    incomment swap put disc
  end

  prevsep 1 put disc
  instring 0 put disc
  linecomm 0 put disc
  incall 0 put disc
  prevhl HL_NORMAL put disc

  scslen 
  buffer.current read buffer.syntax . read editorsyntax.scomment . read
  copy NULL != if cstr.len end
  put disc

  mcslen
  buffer.current read buffer.syntax . read editorsyntax.mcomments . read
  copy NULL != if cstr.len end
  put disc

  mcelen 
  buffer.current read buffer.syntax . read editorsyntax.mcommente . read
  copy NULL != if cstr.len end
  put disc

  0
  do
    altchar swap put disc

    scslen read 0 !=
    incomment read ! &&
    instring read ! && if
      altchar read tmprow read erow.render . read +
      buffer.current read buffer.syntax . read editorsyntax.scomment . read
      scslen read
      (mem.eq) if
        linecomm 1 put disc
      end
    end

    mcslen read 0 != 
    mcelen read 0 != && 
    instring read ! && if
      incomment read
      copy if
        altchar read tmprow read erow.hl . read + HL_MLCOMMENT putc disc

        altchar read tmprow read erow.render . read +
        buffer.current read buffer.syntax . read editorsyntax.mcommente . read
        mcelen read
        (mem.eq) if
          altchar copy read mcelen read 1 - + put disc
          incomment 0 put disc
          prevsep 1 put disc
        end
      end
      ! 
      altchar read tmprow read erow.render . read +
      buffer.current read buffer.syntax . read editorsyntax.mcomments . read
      mcslen read 
      (mem.eq) && if
        altchar copy read mcslen read 1 - + put disc
        incomment 1 put disc
      end
    end

    prevsep read
    instring read ! &&
    if
      altchar read tmprow read erow.render . read +
      buffer.current read buffer.syntax . read editorsyntax.kw1 . read
      checkkw
      copy if
        altchar read tmprow read erow.render . read + covr + readc
        sepr if
          copy
          altchar read tmprow read erow.hl . read + swap
          HL_KEYWORD1 swap
          (mem.set)
        end
      end
      disc

      altchar read tmprow read erow.render . read +
      buffer.current read buffer.syntax . read editorsyntax.kw2 . read
      checkkw
      copy if
        altchar read tmprow read erow.render . read + covr + readc
        sepr if
          copy
          altchar read tmprow read erow.hl . read + swap
          HL_KEYWORD2 swap
          (mem.set)
        end
      end
      disc
    end

    buffer.current read buffer.syntax . read editorsyntax.flags . read
    copy HLF_NUMBERS && if
      altchar read tmprow read erow.render . read + readc 
      copy '0' < ! swap '9' > ! &&
      prevsep read
      prevhl read HL_NUMBER == || &&
      if 
        altchar read tmprow read erow.hl . read + HL_NUMBER putc disc
      end

      prevhl
      altchar read tmprow read erow.hl . read + readc
      put disc
    end
    copy HLF_STRINGS && if
      instring read
      copy if
        altchar read tmprow read erow.hl . read + HL_STRING putc disc
        altchar read tmprow read erow.render . read + readc 
        instring read == if
          instring 0 put disc
        end
        prevsep 1 put disc
      end
      0 == if
        altchar read tmprow read erow.render . read + readc 
        copy '"' ==
        covr '`' == ||
        covr ''' == || if
          instring
          covr
          put disc
          altchar read tmprow read erow.hl . read + HL_STRING putc disc
        end
        disc
      end
    end
    copy HLF_CALLS && if
      incall read
      copy if
        altchar read tmprow read erow.hl . read + HL_CALL putc disc
        altchar read tmprow read erow.render . read + readc 
        incall read == if
          incall 0 put disc
        end
        prevsep 1 put disc
      end
      0 == if
        altchar read tmprow read erow.render . read + readc 
        copy '(' == if
          incall
          ')'
          put disc
          altchar read tmprow read erow.hl . read + HL_CALL putc disc
        end
        disc
      end
    end
    disc

    linecomm read 0 != if
      altchar read tmprow read erow.hl . read + HL_COMMENT putc disc
    end

    incomment read 0 != if
      altchar read tmprow read erow.hl . read + HL_COMMENT putc disc
    end

    prevsep
    altchar read tmprow read erow.render . read + readc sepr
    put disc

    altchar read 1 +
    altchar read
    tmprow read erow.rsize . read <
  end
  disc

  tmprow read erow.hlopencomment .
  incomment read
  covr covr != if
    tmprow read erow.idx . read 1 + getrow
    NULL != if
      tmprow read erow.idx . read 1 + getrow
      erow.hl . read NULL != if
        tmprow read erow.idx . read 1 + getrow
        erow.hl . read (heap.free)
        
        tmprow read erow.idx . read 1 + getrow
        erow.hl . NULL put disc
      end
    end
  end
  put disc

  altchar 0 put disc

  ret
end

oper proc updaterow 0 0
  tmprow read erow.render . read NULL != if
    ret
  end

  tmpstr (str.new) put disc

  altchar 0 put disc
  0
  do
    copy tmprow read erow.chars . read + readc
    altchar swap putc disc

    altchar readc 9 == if
      tmpstr read
      do
        " " (str.catc)

        tmpstr read str.size . read TABSIZE /% swap disc 0 !=
      end
      tmpstr swap put disc

      ret
    end

    tmpstr read
    altchar (str.catc)
    tmpstr swap put disc
  
    1 +
    copy tmprow read erow.size . read <
  end
  disc

  altchar 0 put disc

  tmprow read erow.rsize .
  tmpstr read str.size . read 1 -
  put disc
  
  tmprow read erow.render .
  tmpstr read str.size . read
  (heap.zalloc)
  put disc

  tmprow read erow.render . read
  tmpstr read str.data .
  tmpstr read str.size . read
  (mem.cpy)

  tmprow read erow.hl . read NULL != if
    tmprow read erow.hl . read (heap.free)
    tmprow read erow.hl . NULL put disc
  end
  
  tmpstr read (str.free)

  ret
end

var tmpsize int.SIZE

oper proc cxtorx 1 1
  tmprow
  buffer.current read buffer.cy . read getrow
  put disc

  tmpsize 0 put disc

  0
  swap 1 -
  range.for : 1 0
    altchar 0 put disc
    read tmprow read erow.chars . read + readc
    altchar swap putc disc

    altchar readc 9 == if
      do
        tmpsize copy read 1 + put disc

        tmpsize read TABSIZE /% swap disc 0 !=
      end
      ret
    end
    tmpsize copy read 1 + put disc

    ret
  end

  tmpsize read

  ret
end

oper proc updateft 0 0
  tmpstr (str.new) put disc

  tmpchar 0 put disc

  buffer.current read buffer.filename . read
  do
    tmpchar
    covr readc
    putc disc

    tmpstr read
    tmpchar (str.catc)
    tmpstr swap put disc

    tmpchar readc '.' == if
      tmpstr read str.size . 0 put disc
    end

    1 +
    copy readc 0 !=
  end
  disc

  0
  do
    copy getrow NULL == if brk end
    copy resetrow
    
    1 +

    1  
  end
  disc

  tmpstr read str.data .
  tmpstr read str.size . read + 0 putc disc

  tmpstr read str.data . "slm" (cstr.eq) if
    buffer.current read buffer.syntax .
    "brk\0nop\0ret\0asm\0quit\0copy\0covr\0readc\0read\0putc\0put\0disc\0argv\0argc\0envp\0of\0temp\0push\0oper\0-\0*\0,\0/%\0+\0^\0!=\0!\0==\0<\0>\0&&\0~\0()\0sys0\0sys1\0sys2\0sys3\0sys4\0sys5\0sys6\0"
    "sim\0lambda\0swap\0dump\0const\0if\0proc\0do\0end\0inc\0enum\0var\0prop\0class\0cproc\0lnk\0"
    "{" "}" "$$"
    "slam" HLF_NUMBERS HLF_CALLS || HLF_STRINGS || editorsyntax.new
    put disc

    tmpstr read (str.free)

    ret
  end

  tmpstr read str.data . "spk" (cstr.eq) if
    buffer.current read buffer.syntax .
    "\0"
    "src\0lib\0libd\0"
    "{" "}" "$$"
    "spakig" HLF_STRINGS editorsyntax.new
    put disc

    tmpstr read (str.free)

    ret
  end

  tmpstr read (str.free)

  ret
end

{ file io }
oper proc editoropen 1 0
  buffer.current read buffer.filename . read NULL !=
  buffer.current read buffer.dirty . read 0 != ||
  if
    addbuffer
  end

  copy buffer.current read buffer.filename . swap put disc

  (filestream.new)
  tmpfp swap put disc

  tmpfp read NULL == if
    copy buffer.current read buffer.filename . read setstatus
    "" insertrow

    ret
  end

  0
  do
    copy getrow NULL == if brk end
    copy getrow erow.free
    
    1 +

    1  
  end
  disc
  
  buffer.current read buffer.numrows . 0 put disc

  do
    tmpln (str.new) put disc
    tmpchar 0 put disc
    do
      tmpchar
      tmpfp read (filestream.readchar)
      putc disc

      tmpchar readc
      copy 10 == if
        disc
        brk
      end
      copy 13 == if
        disc
        brk
      end
      copy 0 == if
        disc
        brk
      end
      disc
      
      tmpln read
      tmpchar
      (str.catc)
      tmpln swap put disc 

      1
    end
    tmpchar readc 0 ==
    tmpln read str.size . read 0 == && !
    if
      tmpln read str.data . insertrow
      buffer.current read buffer.cy . copy read 1 + put disc
    end
    
    tmpchar readc 0 !=
  end

  buffer.current read buffer.cx . 0 put disc
  buffer.current read buffer.cy . 0 put disc

  "Opened " setstatus
  buffer.current read buffer.filename . read appendstatus

  updateft

  ret
end

oper proc insertchar 1 0
  buffer.current read buffer.cy . read getrow erow.chars . read
  buffer.current read buffer.cy . read getrow erow.size . read 2 +
  (heap.realloc)
  buffer.current read buffer.cy . read getrow erow.chars . swap put disc

  buffer.current read buffer.cx . read
  tmpat swap put disc
  
  tmpat read 0 < 
  tmpat read
  buffer.current read buffer.cy . read getrow erow.size . read > ||
  if 
    disc
    buffer.current read buffer.cy . read getrow erow.size . read
  end

  buffer.current read buffer.cy . read getrow erow.chars . read tmpat read +
  buffer.current read buffer.cy . read getrow erow.chars . read tmpat read + 1 +
  buffer.current read buffer.cy . read getrow erow.size . read tmpat read - 1 +
  movemem

  buffer.current read buffer.cy . read getrow erow.size . copy read 1 + put disc

  buffer.current read buffer.cx . copy read 1 + put disc
  
  buffer.current read buffer.cy . read getrow erow.chars . read
  tmpat read + swap putc disc

  buffer.current read buffer.cy . read resetrow

  ret
end

oper proc insertline 0 0
  buffer.current read buffer.cy . copy read 1 + put disc
  buffer.current read buffer.cy . read 1 - getrow erow.chars . read
  buffer.current read buffer.cx . read +
  insertrow
  buffer.current read buffer.cy . read 1 - getrow erow.chars . read
  buffer.current read buffer.cx . read + 0 putc disc

  buffer.current read buffer.cy . read 1 - getrow erow.size .
  buffer.current read buffer.cx . read
  put disc

  buffer.current read buffer.cy . read 1 - resetrow
  buffer.current read buffer.cx . 0 put disc

  ret
end

oper proc delrow 1 0
  tmpat swap put disc

  tmpat read getrow erow.free
  
  tmpat read 1 + int.SIZE *
  buffer.current read buffer.rows . read + 
  tmpat read int.SIZE *
  buffer.current read buffer.rows . read + 
  buffer.current read buffer.numrows . read tmpat read - int.SIZE *
  movemem

  buffer.current read buffer.numrows . copy read 1 - put disc

  ret
end

oper proc appendrow 1 0
  tmpat swap put disc
  tmpstr (str.new) put disc

  tmpstr read
  tmpat read getrow erow.chars . read (str.catc)
  tmpat read 1 + getrow erow.chars . read (str.catc)
  tmpstr swap put disc

  tmpat read getrow erow.chars . read
  tmpstr read str.size . read
  (heap.realloc)
  tmpat read getrow erow.chars . swap put disc
  
  tmpat read getrow erow.chars . read
  tmpstr read str.data .
  tmpstr read str.size . read
  (mem.cpy)

  tmpat read getrow erow.size .
  tmpstr read str.size . read
  put disc
  
  tmpstr read (str.free)

  buffer.current read buffer.cy . read resetrow

  ret
end

oper proc delchar 1 0
  tmpat swap put disc
 
  tmpat read -1 ==
  buffer.current read buffer.cy . read 0 == && if ret end

  tmpat read -1 == if
    buffer.current read buffer.cx .
    buffer.current read buffer.cy . read 1 - getrow erow.size . read
    put disc

    buffer.current read buffer.cy . read 1 -
    appendrow
    buffer.current read buffer.cy . read
    delrow
    buffer.current read buffer.cy . copy read 1 - put disc

    buffer.current read buffer.cy . read resetrow

    ret
  end
  
  tmpat read 0 < 
  tmpat read
  buffer.current read buffer.cy . read getrow erow.size . read < ! ||
  if 
    disc
    ret
  end

  buffer.current read buffer.cy . read getrow erow.chars . read tmpat read + 1 +
  buffer.current read buffer.cy . read getrow erow.chars . read tmpat read +
  buffer.current read buffer.cy . read getrow erow.size . read tmpat read - 1 +
  movemem

  buffer.current read buffer.cy . read getrow erow.size . copy read 1 - put disc

  buffer.current read buffer.cx . copy read 1 - put disc

  buffer.current read buffer.cy . read resetrow

  ret
end

oper proc rowstostr 0 0
  tmpln (str.new) put disc

  0
  buffer.current read buffer.numrows . read 1 -
  range.for : 1 0
    read getrow
    tmprow swap put disc

    tmprow read NULL == if ret end

    tmprow read erow.chars . read
    tmprow read erow.size . read + 0 putc disc

    tmpln read
    tmprow read erow.chars . read (str.catc)
    "\n" (str.catc)
    tmpln swap put disc

    ret
  end

  ret
end

oper proc rawmodeon 0 0
  raw
  5401h
  0
  sysc.IOCTL
  sys3
  disc

  buffer.current read buffer.starttermios .
  raw termios.SIZE (mem.cpy)

  raw termios.iflag .
  copy read
  BRKINT ICRNL || INPCK || ISTRIP || IXON || ~ &&
  put disc

  raw termios.oflag .
  copy read
  OPOST ~ &&
  put disc

  raw termios.lflag .
  copy read
  ECHO ISIG || ICANON || IEXTEN || ~ &&
  put disc

  raw termios.cc . VMIN + 0 putc disc
  raw termios.cc . VTIME + 1 putc disc

  raw
  5404h
  0
  sysc.IOCTL
  sys3
  disc

  ret
end

oper proc rawmodeoff 0 0
  buffer.current read buffer.starttermios .
  5404h
  0
  sysc.IOCTL
  sys3
  disc

  ret
end

oper proc die 1 0
  cstr.print
  "\e[2J" cstr.print
  "\e[H" cstr.print
  rawmodeoff

  1 quit
end

var tmplen int.SIZE

class renderer
  var abuf int.SIZE
  var leftbuf int.SIZE
  var rightbuf int.SIZE
  var fgcolor int.SIZE
  var bgcolor int.SIZE

  oper proc setfgcolor 1 0
    renderer.fgcolor read covr == if disc ret end
    renderer.fgcolor swap put disc

    renderer.abuf read
    "\e[38;5;" (str.catc)
    renderer.fgcolor read int.cstr (str.catc)
    "m" (str.catc)
    renderer.abuf swap put disc

    ret
  end

  oper proc setbgcolor 1 0
    renderer.bgcolor read covr == if disc ret end
    renderer.bgcolor swap put disc

    renderer.abuf read
    "\e[48;5;" (str.catc)
    renderer.bgcolor read int.cstr (str.catc)
    "m" (str.catc)
    renderer.abuf swap put disc

    ret
  end

  oper proc renderstatus 0 0
    renderer.leftbuf (str.new) put disc
    renderer.rightbuf (str.new) put disc

    253 renderer.setfgcolor
    252 renderer.setbgcolor

    renderer.rightbuf read
    buffer.current read buffer.cy . read int.cstr (str.catc)
    "/" (str.catc)
    buffer.current read buffer.numrows . read int.cstr (str.catc)
    " " (str.catc)
    "no ft"
    buffer.current read buffer.syntax . read NULL != if
      disc buffer.current read buffer.syntax . read editorsyntax.name . read
    end (str.catc)
    renderer.rightbuf swap put disc

    renderer.leftbuf read
    " " (str.catc)
    mode read modetostr (str.catc)
    " ┃" (str.catc)
    renderer.leftbuf swap put disc
    
    buffer.cnt 1 != if
      0
      do
        buffer.buffers read
        covr
        (dlist.ptrat)
        copy NULL == if disc brk end
        read buffer.filename .
        copy NULL != if read end
        covr
        
        renderer.leftbuf read
        " " (str.catc)
        covr int.cstr (str.catc)
        ":" (str.catc)
        swap buffer.idx read == " " swap if
          disc "_"
        end (str.catc)
        swap (str.catc)
        covr buffer.idx read == " " swap if
          disc "_"
        end (str.catc)
        renderer.leftbuf swap put disc

        1 +
        1
      end
      disc
      renderer.leftbuf read
      " ┃ " (str.catc)
      renderer.leftbuf swap put disc
    end

    renderer.leftbuf read
    "[NO NAME]"
    buffer.current read buffer.filename . read NULL != if
      disc buffer.current read buffer.filename . read
    end (str.catc)
    buffer.current read buffer.dirty . read if
      " (modified)" (str.catc)
    end
    renderer.leftbuf swap put disc

    renderer.leftbuf read str.size . read
    screen.width read  >
    if
      renderer.leftbuf read str.size . 
      screen.width read 
      put disc

      renderer.leftbuf read str.size . read 1 + 
      renderer.leftbuf read str.data . +
      0 putc disc
    end

    renderer.abuf read
    renderer.leftbuf read str.data . (str.catc)
    renderer.abuf swap put disc

    renderer.leftbuf read str.size . read
    copy
    screen.width read  != if
      do
        renderer.abuf read
        " " (str.catc)
        renderer.abuf swap put disc

        1 +
        copy
        renderer.rightbuf read str.size . read +
        screen.width read  == if
          renderer.abuf read
          renderer.rightbuf read str.data . (str.catc)
          renderer.abuf swap put disc

          brk
        end
        copy screen.width read  <
      end
    end
    disc

    renderer.abuf read
    "\e[m" (str.catc)
    "\r\n" (str.catc)
    "\e[K" (str.catc)
    buffer.current read buffer.statusmsg . (str.catc)
    renderer.abuf swap put disc

    renderer.leftbuf read (str.free)
    renderer.rightbuf read (str.free)

    ret
  end

  oper proc renderrows 0 0
    0
    screen.height read 1 -
    range.for : 1 0
      read buffer.current read buffer.sy . read +

      copy getrow tmprow swap put disc

      copy buffer.current read buffer.numrows . read < ! if 
        renderer.abuf read
        "~" (str.catc)
        renderer.abuf swap put disc
      end
      copy buffer.current read buffer.numrows . read < if
        tmprow read erow.idx . covr put disc
        
        updaterow
        updatehi
        tmprow read erow.rsize . read 
        buffer.current read buffer.sx . read - 1 +
        tmplen swap put disc
        
        tmplen read 0 < if
          tmplen 0 put disc
        end
        
        tmplen read
        screen.width read NUMBERLEN - 1 - > if
          tmplen screen.width read  NUMBERLEN - 1 - put disc
        end

        0 renderer.setbgcolor
        7 renderer.setfgcolor

        renderer.abuf read str.size . read NUMBERLEN + 1 -
        tmprow read erow.idx . read int.cstr cstr.len -

        do
          renderer.abuf read
          " " (str.catc)
          renderer.abuf swap put disc

          renderer.abuf read str.size . read 
          covr <
        end
        disc

        renderer.abuf read
        tmprow read erow.idx . read int.cstr (str.catc)
        "│" (str.catc)
        renderer.abuf swap put disc

        0 renderer.setbgcolor
        7 renderer.setfgcolor

        tmplen read 0 > if
          tmpchar 0 put disc
          0
          do
            copy tmprow read erow.render . read +
            buffer.current read buffer.sx . read +
            readc
            tmpchar swap putc disc

            copy tmprow read erow.hl . read + readc
            hltocolor renderer.setfgcolor
            
            tmpchar readc iscntrl ! if
              renderer.abuf read
              tmpchar (str.catc)
              renderer.abuf swap put disc
            end
            tmpchar readc iscntrl if
              7 renderer.setbgcolor
              0 renderer.setfgcolor
              renderer.abuf read
              tmpchar readc 26 < if
                tmpchar readc '@' +
                altchar swap putc (str.catc)
              end
              tmpchar readc 26 < ! if
                tmpchar '?' putc (str.catc)
              end
              renderer.abuf swap put disc
              0 renderer.setbgcolor
              7 renderer.setfgcolor
            end

            1 +
            copy tmplen read <
          end
          disc
        end
      end
      disc
      renderer.abuf read
      "\e[K" (str.catc)
      "\r\n" (str.catc)
      renderer.abuf swap put disc

      ret
    end

    ret
  end

  oper proc blit 0 0
    renderer.abuf read
    (str.print)

    ret
  end

  oper proc movecursor 0 0
    buffer.current read buffer.rx . read 1 + NUMBERLEN +
    buffer.current read buffer.sx . read -
    buffer.current read buffer.cy . read 1 +
    buffer.current read buffer.sy . read -

    renderer.abuf read
    "\e[" (str.catc)
    swap int.cstr (str.catc)
    ";" (str.catc)
    swap int.cstr (str.catc)
    "H" (str.catc)
    renderer.abuf swap put disc

    ret
  end

  oper proc refreshscreen 0 0
    renderer.abuf
    (str.new)
    put disc

    renderer.abuf read
    "\e[?25l" (str.catc)
    "\e[H" (str.catc)
    renderer.abuf swap put disc

    renderer.renderrows
    renderer.renderstatus
    renderer.movecursor

    renderer.abuf read
    "\e[?25h" (str.catc)
    renderer.abuf swap put disc

    renderer.blit

    renderer.abuf read
    (str.free)

    ret
  end
end

var pbuff int.SIZE
var psize int.SIZE

oper proc prompt 1 1
  psize
  covr cstr.len
  put disc

  pbuff (str.new) put disc

  pbuff read
  swap (str.catc)
  pbuff swap put disc

  do
    pbuff read str.data . setstatus
    renderer.refreshscreen
    tmpchar 0 put disc
    1 tmpchar 0 (os.readf)

    tmpchar readc 13 == if 
      "" setstatus
      pbuff read str.data . 
      pbuff read str.size . read + 0 putc disc 
      pbuff read str.data . psize read +
      ret
    end
    tmpchar readc 'q' CTRL == if
      NULL
      ret
    end
    pbuff read str.size . read 0 !=
    tmpchar readc 127 == && if
      pbuff read str.size . copy read 1 - put disc
      pbuff read str.data . 
      pbuff read str.size . read + 0 putc disc 
    end
    tmpchar readc 32 >
    tmpchar readc 127 < &&
    tmpchar readc 0 != && if
      pbuff read
      tmpchar (str.catc)
      pbuff swap put disc
    end

    1
  end

  NULL ret
end

class runner
  oper proc run 0 0
    {
    511
    65
    "/tmp/runner.slm"
    -100
    (os.open)
    tmpfp swap put disc

    tmpstr (str.new) put disc

    tmpstr read
    "proc main " (str.catc)
    ">>" prompt (str.catc)
    " end " (str.catc)
    tmpstr swap put disc

    tmpstr read str.size . read
    tmpfp read
    77
    sys2
    disc

    tmpstr read str.size . read
    tmpstr read str.data .
    tmpfp read
    (os.write)

    tmpstr read (str.free)

    tmpfp read
    (os.close)

    "/tmp/runner.slm"

    bool.false
    (lexer.new) (lexer.run)
    (parser.new) (parser.run)
    (simulator.visitnode)
    simulator.SUCCESS != if
      "ERR" setstatus
    end
    }

    ret
  end
end

oper proc save 0 0
  buffer.current read buffer.filename . read NULL == if
    "Save As: " prompt
    copy NULL == if disc ret end

    buffer.current read buffer.filename . swap put disc

    updateft
  end

  rowstostr
  
  511
  65
  buffer.current read buffer.filename . read
  -100
  (os.open)
  tmpfp swap put disc

  tmpln read str.size . read
  tmpfp read
  77
  sys2
  disc

  tmpln read str.size . read
  tmpln read str.data . 
  tmpfp read
  (os.write)

  tmpfp read
  (os.close)

  tmpln read str.size . read
  "Wrote " setstatus
  int.cstr appendstatus
  " bytes" appendstatus

  tmpln read (str.free)

  buffer.current read buffer.dirty . 0 put disc

  ret
end

oper proc getsize 0 0
  ws
  5413h
  1
  sysc.IOCTL
  sys3
  disc

  screen.height
  ws winsize.row . read 65535 && 2 -
  put disc

  screen.width
  ws winsize.col . read 65535 && 1 +
  put disc

  ret
end

var nread int.SIZE

oper proc readchar 0 1
  tmpchar
  0
  putc disc

  do
    1 tmpchar 0 (os.readf)
    nread swap put disc

    nread read -1 ==
  end

  tmpchar readc
  copy 27 == if
    1 tmpchar 0 (os.readf)
    tmpchar readc

    copy '[' == if
      1 tmpchar 0 (os.readf)
      tmpchar readc

      copy 'A' == if 
        disc disc disc
        EK_ARROW_UP ret
      end
      copy 'B' == if 
        disc disc disc
        EK_ARROW_DOWN ret
      end
      copy 'C' == if 
        disc disc disc
        EK_ARROW_RIGHT ret
      end
      copy 'D' == if 
        disc disc disc
        EK_ARROW_LEFT ret
      end
      copy 'H' == if 
        disc disc disc
        EK_HOME ret
      end
      copy 'D' == if 
        disc disc disc
        EK_END ret
      end
      copy 'P' == if 
        disc disc disc
        EK_DEL ret
      end

      copy '1' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_HOME ret
        end
        disc
      end
      copy '3' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_DEL ret
        end
        disc
      end
      copy '4' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_END ret
        end
        disc
      end
      copy '5' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_PAGE_UP ret
        end
        disc
      end
      copy '6' == if
        1 tmpchar 0 (os.readf)
        tmpchar readc
        copy '~' == if 
          disc disc disc disc
          EK_PAGE_DOWN ret
        end
        disc
      end
      disc
    end
    copy 'O' == if
      1 tmpchar 0 (os.readf)
      tmpchar readc

      copy 'H' == if 
        disc disc disc
        EK_HOME ret
      end
      copy 'D' == if 
        disc disc disc
        EK_END ret
      end
      disc
    end
    disc
  end

  ret
end

oper proc scroll 0 0
  buffer.current read buffer.rx .
  0 put disc

  buffer.current read buffer.cy . read
  buffer.current read buffer.numrows . read < if
    buffer.current read buffer.rx .
    buffer.current read buffer.cx . read
    cxtorx put disc
  end

  buffer.current read buffer.sy . read 
  buffer.current read buffer.cy . read > if
    buffer.current read buffer.sy .
    buffer.current read buffer.cy . read
    put disc
  end

  buffer.current read buffer.sy . read 
  screen.height read +
  buffer.current read buffer.cy . read > ! if
    buffer.current read buffer.sy .

    buffer.current read buffer.cy . read
    screen.height read - 1 +
    
    put disc
  end
  buffer.current read buffer.sx . read 
  buffer.current read buffer.rx . read > if
    buffer.current read buffer.sx .
    buffer.current read buffer.rx . read
    put disc
  end

  buffer.current read buffer.sx . read 
  screen.width read +
  buffer.current read buffer.rx . read > ! if
    buffer.current read buffer.sx .

    buffer.current read buffer.rx . read
    screen.width read - 1 +
    
    put disc
  end

  ret
end

enum
0   UP
    DOWN
    LEFT
    RIGHT
end

oper proc movecursor 1 0
  copy UP == if 
    buffer.current read buffer.cy . read 0 > if
      buffer.current read buffer.cy . copy read 1 - put disc
    end
  end
  copy DOWN == if 
    buffer.current read buffer.cy . read
    buffer.current read buffer.numrows . read 1 - < if
      buffer.current read buffer.cy . copy read 1 + put disc
    end
  end
  copy LEFT == if
    buffer.current read buffer.cx . read 0 != if 
      disc
      buffer.current read buffer.cx . copy read 1 - put disc

      ret
    end
    buffer.current read buffer.cy . read 0 > if 
      buffer.current read buffer.cy . copy read 1 - put disc
      
      buffer.current read buffer.cx .
      buffer.current read buffer.cy . read getrow erow.size . read
      put disc
      
    end
  end
  copy RIGHT == if
    buffer.current read buffer.cy . read getrow
    NULL != if
      buffer.current read buffer.cx . read 
      buffer.current read buffer.cy . read getrow erow.size . read
      < if 
        disc
        buffer.current read buffer.cx . copy read 1 + put disc

        ret
      end
      buffer.current read buffer.cx . read 
      buffer.current read buffer.cy . read getrow erow.size . read
      == if 
        buffer.current read buffer.cy . copy read 1 + put disc
        disc
        buffer.current read buffer.cx . 0 put disc

        ret
      end
    end
  end
  disc

  buffer.current read buffer.cx . read 
  buffer.current read buffer.cy . read getrow erow.size . read > if
    buffer.current read buffer.cx .
    buffer.current read buffer.cy . read getrow erow.size . read
    put disc
  end
  
  ret
end

oper proc processkey 1 0
  copy 's' CTRL == if
    save

    disc ret
  end
  copy 'r' CTRL == if
    runner.run

    disc ret
  end
  copy 'g' CTRL == if
    buffer.current read buffer.cy .
    buffer.current read buffer.numrows . read 1 -
    put disc
    
    buffer.current read buffer.cx .
    buffer.current read buffer.cy . read getrow erow.size . read
    put disc

    disc ret
  end
  copy 'q' CTRL == if
    "\e[2J" cstr.print
    "\e[H" cstr.print

    rawmodeoff
    
    0 quit
  end
  copy 13 == if
    insertline

    disc ret
  end
  copy EK_BACKSPACE ==
  covr 'h' CTRL == || if 
    buffer.current read buffer.cx . read 1 -
    delchar

    disc ret
  end
  covr EK_DEL == if
    RIGHT movecursor
    buffer.current read buffer.cx . read 1 -
    delchar

    disc ret
  end
  copy EK_ARROW_UP == if 
    UP movecursor

    disc ret
  end
  copy EK_ARROW_DOWN == if 
    DOWN movecursor

    disc ret
  end
  copy EK_ARROW_LEFT == if 
    LEFT movecursor

    disc ret
  end
  copy EK_ARROW_RIGHT == if 
    RIGHT movecursor

    disc ret
  end
  copy EK_PAGE_UP == if 
    screen.height read
    do
      UP movecursor
      1 - copy
    end
    disc

    disc ret
  end
  copy EK_PAGE_DOWN == if 
    screen.height read
    do
      DOWN movecursor
      1 - copy
    end
    disc

    disc ret
  end
  copy 'o' CTRL == if
    "Open: " prompt
    copy NULL == if disc ret end
    editoropen

    disc ret
  end
  copy 'n' CTRL == if
    buffer.idx copy read 1 +
    buffer.cnt /% swap disc put disc

    disc ret
  end
  copy 'p' CTRL == if
    buffer.idx copy read 1 -
    buffer.cnt /% swap disc put disc

    disc ret
  end
  copy 9 == if
    9 insertchar

    disc ret
  end
  copy iscntrl
  covr 'l' CTRL == ||
  covr 27 == || if
    disc ret
  end

  insertchar

  ret
end

oper proc main 0 0
  initbuffers

  argc 1 > if 
    1 (os.args) editoropen
  end
  argc 1 == if 
    "" insertrow
  end

  rawmodeon
  getsize

  scroll
  renderer.refreshscreen
  do
    readchar
    copy if
      processkey 0
      scroll
      renderer.refreshscreen
    end
    disc

    1
  end

  ret
end
